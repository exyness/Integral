# Requirements Document

## Introduction

This document specifies the requirements for implementing a RAG (Retrieval-Augmented Generation) Search System for Integral. The system provides AI-powered semantic search capabilities across the user's personal knowledge base (notes, journal entries, tasks) using natural language queries. Content is automatically indexed with vector embeddings generated via Google Gemini, stored in Supabase with pgvector extension, and retrieved using cosine similarity matching to provide contextual AI-generated responses. The design prioritizes seamless integration with existing content creation flows, graceful error handling, and a delightful Halloween-themed experience.

## Glossary

- **RAG System**: The Retrieval-Augmented Generation system that combines vector similarity search with AI response generation
- **Embedding**: A 3072-dimensional numerical vector representation of text content generated by Google Gemini's gemini-embedding-001 model
- **Search Index**: The Supabase `search_index` table storing content, metadata, and vector embeddings with pgvector extension
- **Grimoire**: The themed name for the knowledge base in Halloween mode (normal mode: "Knowledge Base")
- **Similarity Threshold**: The minimum cosine similarity score (0.5) required for a document to be considered a match
- **Match Count**: The maximum number of similar documents (5) returned per query
- **Content Types**: The categories of indexed content (note, journal, task)
- **pgvector**: PostgreSQL extension enabling vector similarity search operations
- **Cosine Similarity**: Mathematical measure of similarity between two vectors (1.0 = identical, 0.0 = orthogonal)
- **Streaming Response**: AI response delivered incrementally as tokens are generated
- **Optimistic Update**: UI update that occurs immediately before server confirmation
- **TanStack Query**: React library for server state management with caching
- **Integral**: The productivity suite application

## Requirements

### Requirement 1

**User Story:** As a user, I want my notes, journal entries, and tasks to be automatically indexed for search, so that I can find relevant information using natural language queries without manual tagging or organization.

#### Acceptance Criteria

1. WHEN a user creates a new note, THE **Integral** application SHALL generate an **Embedding** for the note content using Google Gemini's text-embedding-004 model
2. WHEN a note embedding is generated, THE **Integral** application SHALL store it in the **Search Index** with metadata including type ("note"), original_id (note UUID), title, category, and tags array
3. WHEN a user creates a new journal entry, THE **Integral** application SHALL generate an **Embedding** for the entry content
4. WHEN a journal embedding is generated, THE **Integral** application SHALL store it in the **Search Index** with metadata including type ("journal"), original_id (entry UUID), date, and title
5. WHEN a user creates a new task, THE **Integral** application SHALL generate an **Embedding** for the task title and description combined
6. WHEN a task embedding is generated, THE **Integral** application SHALL store it in the **Search Index** with metadata including type ("task"), original_id (task UUID), priority, status, due_date, and project
7. WHEN **Embedding** generation fails, THE **Integral** application SHALL log the error and allow the content creation to succeed without blocking the user
8. WHEN **Embedding** generation fails, THE **Integral** application SHALL NOT display an error toast to the user (silent failure)
9. WHEN content is indexed, THE **Integral** application SHALL store both the original content text and the embedding vector

### Requirement 2

**User Story:** As a user, I want to search my knowledge base using natural language, so that I can find relevant information without remembering exact keywords or where I stored information.

#### Acceptance Criteria

1. WHEN a user submits a search query, THE **RAG System** SHALL generate an **Embedding** for the query text using the same model used for indexing
2. WHEN a query **Embedding** is generated, THE **RAG System** SHALL call the `match_documents` RPC function with the embedding vector
3. THE `match_documents` RPC function SHALL use a **Similarity Threshold** of 0.5 to filter results
4. THE `match_documents` RPC function SHALL return a maximum of 5 documents (**Match Count**)
5. WHEN matching documents are found, THE **RAG System** SHALL return documents ordered by **Cosine Similarity** score in descending order (highest similarity first)
6. WHEN no documents meet the **Similarity Threshold**, THE **RAG System** SHALL return an empty result set
7. THE **RAG System** SHALL only return documents belonging to the authenticated user (enforced by RLS)

### Requirement 3

**User Story:** As a user, I want AI-generated responses based on my search results, so that I can get contextual answers to my questions rather than just a list of documents.

#### Acceptance Criteria

1. WHEN search results are retrieved, THE **RAG System** SHALL concatenate the content of matched documents as context for the AI prompt, separated by double newlines
2. WHEN generating a response, THE **RAG System** SHALL use Google Gemini (gemini-2.0-flash) to produce an answer based only on the retrieved context
3. WHEN the context contains no relevant information, THE **RAG System** SHALL indicate that no relevant information was found in the knowledge base
4. WHEN in Halloween mode, THE **RAG System** SHALL use themed language ("Grimoire", "ancient knowledge", "spirits") in prompts and responses
5. WHEN in normal mode, THE **RAG System** SHALL use standard language ("knowledge base", "your notes") in prompts and responses
6. WHEN response generation is in progress, THE **RAG System** SHALL stream the response text incrementally to the UI using **Streaming Response**
7. THE **RAG System** SHALL update the `completion` state with each streamed chunk, appending to previous content
8. WHEN streaming completes, THE **RAG System** SHALL return the full response text

### Requirement 4

**User Story:** As a user, I want to access the search functionality quickly using a keyboard shortcut, so that I can find information without navigating away from my current task.

#### Acceptance Criteria

1. WHEN a user presses Ctrl+K (Windows/Linux), THE **Integral** application SHALL open the search modal
2. WHEN a user presses Cmd+K (Mac), THE **Integral** application SHALL open the search modal
3. WHEN the search modal is open and the user presses Ctrl+K or Cmd+K again, THE **Integral** application SHALL close the search modal
4. WHEN the search modal opens, THE **Integral** application SHALL focus the search input field automatically
5. WHEN the user presses Escape while the search modal is open, THE **Integral** application SHALL close the search modal
6. THE keyboard shortcut SHALL work from any page in the application
7. THE keyboard shortcut SHALL prevent the browser's default behavior (e.g., browser search)

### Requirement 5

**User Story:** As a user, I want to remove content from the search index when I delete items, so that my search results remain accurate and up-to-date.

#### Acceptance Criteria

1. WHEN a user deletes a note, THE **Integral** application SHALL remove the corresponding entry from the **Search Index**
2. WHEN a user deletes a journal entry, THE **Integral** application SHALL remove the corresponding entry from the **Search Index**
3. WHEN a user deletes a task, THE **Integral** application SHALL remove the corresponding entry from the **Search Index**
4. THE removal operation SHALL match entries by user_id, content type, and original_id from metadata
5. WHEN removal fails, THE **RAG System** SHALL log the error and return false without throwing an exception
6. WHEN removal fails, THE **RAG System** SHALL NOT block the parent delete operation

### Requirement 6

**User Story:** As a developer, I want the embedding generation to be reliable and handle errors gracefully, so that the system remains stable under various conditions.

#### Acceptance Criteria

1. WHEN the Gemini API key environment variable (VITE_GEMINI_API_KEY) is missing or empty, THE **RAG System** SHALL log an error message and return null for embedding generation
2. WHEN the Gemini API key is missing, THE **RAG System** SHALL NOT attempt to make an API call
3. WHEN the Gemini API returns an error response, THE **RAG System** SHALL catch the exception, log the error with details, and return null
4. WHEN the Gemini API returns a valid response, THE **RAG System** SHALL extract the embedding values array from the first embedding in the response
5. WHEN the embedding response contains no embeddings (empty array), THE **RAG System** SHALL return null
6. WHEN the embedding response is missing the embeddings field, THE **RAG System** SHALL return null
7. THE **RAG System** SHALL use the text-embedding-004 model for all embedding generation

### Requirement 7

**User Story:** As a user, I want the search interface to match the application's theme, so that I have a consistent and delightful experience.

#### Acceptance Criteria

1. WHEN Halloween mode is enabled, THE search modal SHALL display teal accent color (#60c9b6) for interactive elements
2. WHEN Halloween mode is enabled, THE search modal SHALL display themed placeholder text ("Ask the Grimoire...")
3. WHEN Halloween mode is enabled, THE search modal SHALL display a themed title ("Grimoire Search")
4. WHEN Halloween mode is disabled, THE search modal SHALL display standard placeholder text ("Search your knowledge base...")
5. WHEN Halloween mode is disabled, THE search modal SHALL display a standard title ("Knowledge Search")
6. THE search modal SHALL use glass morphism styling consistent with other modals in the application
7. THE search modal SHALL display a loading indicator while the AI is generating a response
8. THE search modal SHALL display the streamed response with proper formatting (markdown support)

### Requirement 8

**User Story:** As a user, I want to update the search index when I edit content, so that my search results reflect the latest information.

#### Acceptance Criteria

1. WHEN a user updates a note's content, THE **Integral** application SHALL regenerate the **Embedding** and update the **Search Index** entry
2. WHEN a user updates a journal entry's content, THE **Integral** application SHALL regenerate the **Embedding** and update the **Search Index** entry
3. WHEN a user updates a task's title or description, THE **Integral** application SHALL regenerate the **Embedding** and update the **Search Index** entry
4. THE update operation SHALL use upsert logic: delete existing entry and insert new entry with fresh embedding
5. WHEN update indexing fails, THE **Integral** application SHALL log the error and allow the content update to succeed (silent failure)
